#VRML V2.0 utf8

WorldInfo {
	title "Winding mechanism"
	info ["Filip BÃ¡rtek"]
}

# http://www.bellrock.org.uk/lighthouse/lighthouse_lightroom.htm (looks, dimensions)
# http://www.bellrock.org.uk/lighthouse/lighthouse_courses.htm (position)

EXTERNPROTO	BarSquareProto [
	exposedField SFInt32 lod
	field SFVec3f size
	exposedField SFColor diffuseColor
	exposedField SFNode texture
]
"barsquare.wrl#BarSquare"

EXTERNPROTO	CylinderShape [
	field SFNode appearance
	exposedField SFInt32 lod
	field MFFloat range
	field SFFloat radius
	field SFFloat height
	field SFBool top
	field SFBool bottom
	field SFBool solid
	field SFFloat creaseAngle
	field SFInt32 complexity
]
"cylindershape.wrl#CylinderShape"

EXTERNPROTO	Arrow [				 
	exposedField SFInt32 visible
]
"arrow.wrl#Arrow3D"

PROTO Winding [
	exposedField SFInt32 lod 1
	eventOut SFBool	winding_solved
	eventIn	SFBool arrow_visible
]{
	Group {
		children [

Switch {
	choice [
		DEF	Drum Transform {
			children [
				CylinderShape {
					appearance Appearance {
						material Material {
							diffuseColor 0.4 0.2 0.1
						}
					}
					range [200 400]
				}
			]
			scale 0.2 0.2 0.2
		}
		DEF	Hinge Transform	{
			children [
				Transform {
					children [
						Transform {
							children [
								Transform {
									children BarSquareProto {
										diffuseColor 0.1 0.1 0.2
										size 0.05 1 0.05
										lod	IS lod
									}
									translation	0.025 0.5 0
								}
								Transform {
									children Transform {
										children CylinderShape {
											appearance Appearance {
												material Material {
													diffuseColor 0.1 0.1 0.2
												}
											}
											radius 0.025
											height 1
											bottom FALSE
											lod	IS lod
										}
										translation	0 0.5 0
									}
									rotation 0 0 1 -1.57
									translation	0 0.975 0
								}
							]
						}
					]
					scale 0.4 0.4 0.4
					rotation 0 0 1 1.57
				}
				DEF HingeCS CylinderSensor	{
					enabled	FALSE
					minAngle 0
					maxAngle 25.13
				}
			]
			rotation 0 0 1 -1.57
		}
		DEF	RopeAppearance Appearance {
			material Material {
				diffuseColor 0.8 0.8 0
			}
		}
		DEF	RopeCoil Transform {
			children Transform {
				children DEF RopeCylinder CylinderShape {
					appearance USE RopeAppearance
					height 1
					radius 0.25
					lod	IS lod
				}
				translation	0 0.5 0
			}
			scale 1 0.05 1 # Set by script
		}
	]
}

Group {
	children [
		Transform {
			children DEF	Winding Transform {
				children Transform {
					children [
						Transform {
							children [
								USE	Drum
								Transform {
									children USE	RopeCoil
									translation	0 -0.15 0
								}
							]
							rotation 0 0 1 1.57
						}
						Transform {
							children USE Hinge
							translation	0.2 0 0
						}
					]
					rotation 0 0 1 1.57
				}
			}
			rotation 0 0 1 -1.57
		}
		Transform {
			children DEF Arrow Arrow {}
			translation	0 2 0
		}
	]
}

DEF PS ProximitySensor	{
	size 3 3 3
}

		]
	}

DEF	RopeScript Script {
	# This script controls `coil` scale so that its y component runs between
	# `heightMin` and `heightMax` based on rotation `rot` of a CylinderSensor
	# `cylinderSensor`. `cylinderSensor.minAngle` corresponds to `heightMin` and
	# `cylinderSensor.maxAngle` corresponds to `heightMax`.
	# When height surpasses `heightTarget`, `winding_solved` is set to true, indicating
	# a successful solution of the winding puzzle.

	eventIn SFRotation rot # rotation from CylinderSensor
	field SFNode coil USE RopeCoil
	field SFFloat heightMin 0.05
	field SFFloat heightMax 0.3
	field SFFloat heightTarget 0.28 # When height surpasses this value, winding_solved is set to true.
	field SFNode cylinderSensor USE	HingeCS # CylinderSensor
	eventOut SFBool	winding_solved IS winding_solved
	url	"javascript:
		function setCoilHeight(h) {
			var scale = new SFVec3f(1, h, 1);
			coil.scale = scale;
			if (h >= heightTarget) {
				winding_solved = true;
			}
		}
		function initialize() {
			setCoilHeight(heightMin);
		}
		function rot(value) {
			var angle = value[3];
			var angleMin = cylinderSensor.minAngle;
			var angleMax = cylinderSensor.maxAngle;
			var angle01 = (angle - angleMin) / (angleMax - angleMin);
			var height = heightMin + (heightMax - heightMin) * angle01;
			setCoilHeight(height);
		}
	"
	directOutput TRUE
}

ROUTE PS.isActive TO HingeCS.enabled
ROUTE HingeCS.rotation_changed TO Winding.rotation
ROUTE HingeCS.rotation_changed TO RopeScript.rot

}

Winding	{}
